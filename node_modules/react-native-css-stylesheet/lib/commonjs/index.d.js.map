{"version":3,"sources":["index.d.ts"],"names":["isStyleActive","formatStyles","CssStyleSheet"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkJA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AACA;;;;;;;;AA3IO,MAAMA,aAAN;;AAIA,MAAMC,YAAN;AAEP;AACA;AACA;;;AA6HA,MAAMC,aAAN;eAEeA,a","sourcesContent":["import { RegisteredStyle, StyleProp, StyleSheet } from \"react-native\";\r\n\r\nimport type {\r\n\tError,\r\n\tFormattedCssStyleSheet,\r\n\tResponsiveNamedStyles,\r\n\tStyles,\r\n} from \"./types\";\r\n\r\nexport const isStyleActive: (styleCondition: string) => {\r\n\terror?: Error | undefined;\r\n\tflag: boolean;\r\n};\r\nexport const formatStyles: <T extends Styles>(style: T) => T;\r\n\r\n/**\r\n * Creates a StyleSheet style reference from the given object.\r\n */\r\nexport function create<T>(styles: T | ResponsiveNamedStyles): {\r\n\tstyles: StyleSheet.NamedStyles<T>;\r\n\tresponsiveStyles: FormattedCssStyleSheet<T>;\r\n};\r\n\r\ninterface AbsoluteFillStyle {\r\n\tposition: \"absolute\";\r\n\tleft: 0;\r\n\tright: 0;\r\n\ttop: 0;\r\n\tbottom: 0;\r\n}\r\ninterface CssStyleSheet {\r\n\t/**\r\n\t * Creates a StyleSheet style reference from the given object.\r\n\t */\r\n\tcreate: typeof create;\r\n\t/**\r\n\t * Flattens an array of style objects, into one aggregated style object.\r\n\t * Alternatively, this method can be used to lookup IDs, returned by\r\n\t * StyleSheet.register.\r\n\t *\r\n\t * > **NOTE**: Exercise caution as abusing this can tax you in terms of\r\n\t * > optimizations.\r\n\t * >\r\n\t * > IDs enable optimizations through the bridge and memory in general. Refering\r\n\t * > to style objects directly will deprive you of these optimizations.\r\n\t *\r\n\t * Example:\r\n\t * ```\r\n\t * const styles = StyleSheet.create({\r\n\t *   listItem: {\r\n\t *     flex: 1,\r\n\t *     fontSize: 16,\r\n\t *     color: 'white'\r\n\t *   },\r\n\t *   selectedListItem: {\r\n\t *     color: 'green'\r\n\t *   }\r\n\t * });\r\n\t *\r\n\t * StyleSheet.flatten([styles.listItem, styles.selectedListItem])\r\n\t * // returns { flex: 1, fontSize: 16, color: 'green' }\r\n\t * ```\r\n\t * Alternative use:\r\n\t * ```\r\n\t * StyleSheet.flatten(styles.listItem);\r\n\t * // return { flex: 1, fontSize: 16, color: 'white' }\r\n\t * // Simply styles.listItem would return its ID (number)\r\n\t * ```\r\n\t * This method internally uses `StyleSheetRegistry.getStyleByID(style)`\r\n\t * to resolve style objects represented by IDs. Thus, an array of style\r\n\t * objects (instances of StyleSheet.create), are individually resolved to,\r\n\t * their respective objects, merged as one and then returned. This also explains\r\n\t * the alternative use.\r\n\t */\r\n\tflatten<T>(style?: StyleProp<T>): T extends (infer U)[] ? U : T;\r\n\r\n\t/**\r\n\t * Combines two styles such that style2 will override any styles in style1.\r\n\t * If either style is falsy, the other one is returned without allocating\r\n\t * an array, saving allocations and maintaining reference equality for\r\n\t * PureComponent checks.\r\n\t */\r\n\tcompose<T>(\r\n\t\tstyle1: StyleProp<T> | Array<StyleProp<T>>,\r\n\t\tstyle2: StyleProp<T> | Array<StyleProp<T>>\r\n\t): StyleProp<T>;\r\n\r\n\t/**\r\n\t * WARNING: EXPERIMENTAL. Breaking changes will probably happen a lot and will\r\n\t * not be reliably announced. The whole thing might be deleted, who knows? Use\r\n\t * at your own risk.\r\n\t *\r\n\t * Sets a function to use to pre-process a style property value. This is used\r\n\t * internally to process color and transform values. You should not use this\r\n\t * unless you really know what you are doing and have exhausted other options.\r\n\t */\r\n\tsetStyleAttributePreprocessor(\r\n\t\tproperty: string,\r\n\t\tprocess: (nextProp: any) => any\r\n\t): void;\r\n\r\n\t/**\r\n\t * This is defined as the width of a thin line on the platform. It can be\r\n\t * used as the thickness of a border or division between two elements.\r\n\t * Example:\r\n\t * ```\r\n\t *   {\r\n\t *     borderBottomColor: '#bbb',\r\n\t *     borderBottomWidth: StyleSheet.hairlineWidth\r\n\t *   }\r\n\t * ```\r\n\t *\r\n\t * This constant will always be a round number of pixels (so a line defined\r\n\t * by it look crisp) and will try to match the standard width of a thin line\r\n\t * on the underlying platform. However, you should not rely on it being a\r\n\t * constant size, because on different platforms and screen densities its\r\n\t * value may be calculated differently.\r\n\t */\r\n\thairlineWidth: number;\r\n\r\n\t/**\r\n\t * Sometimes you may want `absoluteFill` but with a couple tweaks - `absoluteFillObject` can be\r\n\t * used to create a customized entry in a `StyleSheet`, e.g.:\r\n\t *\r\n\t *   const styles = StyleSheet.create({\r\n\t *     wrapper: {\r\n\t *       ...StyleSheet.absoluteFillObject,\r\n\t *       top: 10,\r\n\t *       backgroundColor: 'transparent',\r\n\t *     },\r\n\t *   });\r\n\t */\r\n\tabsoluteFillObject: AbsoluteFillStyle;\r\n\r\n\t/**\r\n\t * A very common pattern is to create overlays with position absolute and zero positioning,\r\n\t * so `absoluteFill` can be used for convenience and to reduce duplication of these repeated\r\n\t * styles.\r\n\t */\r\n\tabsoluteFill: RegisteredStyle<AbsoluteFillStyle>;\r\n}\r\n\r\nconst CssStyleSheet: CssStyleSheet;\r\n\r\nexport default CssStyleSheet;\r\nexport * as Calculations from \"./calculations\";\r\nexport * from \"./types\";\r\nexport { default as useCssStyleSheet } from \"./utils/useCssStyleSheet\";\r\nexport {\r\n\tdefault as withCssStyleSheet,\r\n\tWithCssStyleSheetProps,\r\n} from \"./utils/withCssStyleSheet\";\r\n"]}