"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  isStyleActive: true,
  formatStyles: true,
  create: true,
  useCssStyleSheet: true,
  withCssStyleSheet: true,
  WithCssStyleSheetProps: true
};
Object.defineProperty(exports, "WithCssStyleSheetProps", {
  enumerable: true,
  get: function () {
    return _withCssStyleSheet.WithCssStyleSheetProps;
  }
});
exports.create = create;
exports.isStyleActive = exports.formatStyles = exports.default = void 0;
Object.defineProperty(exports, "useCssStyleSheet", {
  enumerable: true,
  get: function () {
    return _useCssStyleSheet.default;
  }
});
Object.defineProperty(exports, "withCssStyleSheet", {
  enumerable: true,
  get: function () {
    return _withCssStyleSheet.default;
  }
});

var _reactNative = require("react-native");

var _calculations = require("./calculations");

Object.keys(_calculations).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _calculations[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _calculations[key];
    }
  });
});

var _utils = require("./utils");

var _useCssStyleSheet = _interopRequireDefault(require("./utils/useCssStyleSheet"));

var _withCssStyleSheet = _interopRequireWildcard(require("./utils/withCssStyleSheet"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const isResponsiveKey = /^.*(?:\(|\)|min-|max-|-width|-height|orientation|landscape|portrait).*$/;
const styleRegex = /^\(\s*(?:(?:(?:(min|max)-(width|height)):\s*(.*))|(orientation):\s*(landscape|portrait))\s*\)$/; // const groupRegex = /(?<=\))(?:\s*(?:,)\s*)(?=\()/g;
// const queryRegex = /(?<=\))(?:\s*(?:and)\s*)/g;

const groupRegex = /\)(?:\s*(?:,)\s*)\(/g;
const queryRegex = /\)(?:\s*(?:and)\s*)/g;

const extractGroups = styleKey => {
  const groups = styleKey.split(groupRegex);

  if (groups && groups.length > 0) {
    for (let i = 0; i < groups.length; i += 1) {
      if (i > 0) {
        groups[i] = `(${groups[i]}`;
      }

      if (i < groups.length - 1) {
        groups[i] = `${groups[i]})`;
      }
    }
  }

  return groups;
};

const extractQuery = group => {
  const queries = group.split(queryRegex);

  if (queries && queries.length > 0) {
    for (let i = 0; i < queries.length; i += 1) {
      if (i < queries.length - 1) {
        queries[i] = `${queries[i]})`;
      }
    }
  }

  return queries;
};

const validateAndExtract = styleCondition => {
  var _styleCondition$toLow;

  const styleKey = styleCondition === null || styleCondition === void 0 ? void 0 : (_styleCondition$toLow = styleCondition.toLowerCase()) === null || _styleCondition$toLow === void 0 ? void 0 : _styleCondition$toLow.trim();
  const error = {};
  const results = [];

  if (!styleKey || styleKey.length === 0) {
    error.msg = "String is required";
  } else if (styleKey.startsWith("(") && styleKey.endsWith(")")) {
    const groups = extractGroups(styleKey);

    for (let i = 0; i < groups.length; i += 1) {
      const group = groups[i];
      const groupResults = [];
      const queries = extractQuery(group);
      const conditions = [];
      let breakFlag = false;

      for (let j = 0; j < queries.length; j += 1) {
        const query = queries[j];

        if (query && query.length > 0) {
          const queryResult = (0, _utils.regexTest)(styleRegex, query);

          if (queryResult && queryResult.length > 0) {
            let condition = queryResult[1];

            if (queryResult.length > 3) {
              condition += `-${queryResult[2]}`;
            }

            const common = conditions.indexOf(condition);

            if (common > -1) {
              error.msg = `One group query cannot contain two condition for ${condition}: "${group}`;
              breakFlag = true;
              break;
            } else {
              conditions.push(condition);
            }

            if (queryResult.length > 3) {
              const size = queryResult[3];

              if (!(0, _calculations.isValidSize)(size)) {
                error.msg = `Invalid Size: "${size}"`;
                breakFlag = true;
                break;
              }
            }
          } else {
            error.msg = `Invalid Query: "${query}"`;
            breakFlag = true;
            break;
          }

          groupResults.push(queryResult);
        }
      }

      if (breakFlag) {
        break;
      }

      results.push(groupResults);
    }
  } else {
    const illegalPre = styleKey.slice(0, styleKey.indexOf("("));
    const illegalPost = styleKey.slice(styleKey.lastIndexOf(")") + 1);
    const illegal = illegalPre || illegalPost;
    error.msg = `Illegal Character(s): "${illegal}" in query: "${styleKey}""`;
  }

  return {
    error,
    results
  };
};

const isStyleActive = styleCondition => {
  const {
    results = [],
    error = {}
  } = validateAndExtract(styleCondition) || {};
  let flag = false;

  if (error && Object.keys(error).length === 0 && results && results.length > 0) {
    for (let i = 0; i < results.length; i += 1) {
      const group = results[i];
      let isGroupActive = true;

      for (let j = 0; j < group.length; j += 1) {
        const query = group[j];
        const condition = query[1];
        let value = query[2];
        const dimension = query[2];

        if (query.length > 3) {
          value = query[3];
        }

        if (condition === "orientation" && value === (0, _calculations.getCurrentOrientation)()) {
          isGroupActive = isGroupActive && true;
        } else if ((condition === "min" || condition === "max") && (dimension === "height" || dimension === "width")) {
          const currentDimension = _reactNative.Dimensions.get("window")[dimension];

          const calculatedSize = (0, _calculations.calculateSize)(value);

          if (condition === "min") {
            isGroupActive = isGroupActive && currentDimension >= calculatedSize;
          } else {
            isGroupActive = isGroupActive && currentDimension < calculatedSize;
          }
        } else {
          isGroupActive = isGroupActive && false;
        }

        if (!isGroupActive) {
          break;
        }
      }

      if (isGroupActive) {
        flag = true;
        break;
      }
    }
  }

  return {
    error,
    flag
  };
};

exports.isStyleActive = isStyleActive;

const formatStyles = style => {
  const styleKey = Object.keys(style);
  const formattedStyle = {};

  for (let i = 0; i < styleKey.length; i += 1) {
    const styleProperty = styleKey[i];
    const styleValue = style[styleProperty];
    const size = styleValue;

    if ((0, _calculations.isValidSize)(size)) {
      const calculatedSize = (0, _calculations.calculateSize)(size);
      formattedStyle[styleProperty] = calculatedSize;
    } else {
      formattedStyle[styleProperty] = styleValue;
    }
  }

  return formattedStyle;
};

exports.formatStyles = formatStyles;

function calculateStyles(styles) {
  const stylesKey = Object.keys(styles);
  const finalStyles = {};

  for (let i = 0; i < stylesKey.length; i += 1) {
    const key = stylesKey[i];
    const style = styles[key];
    const formattedStyle = {};
    let responsiveStyle = {};
    const styleKey = Object.keys(style);

    for (let j = 0; j < styleKey.length; j += 1) {
      let insertedStyle = true;
      const styleProperty = styleKey[j];
      const stylePropertyResult = (0, _utils.regexTest)(isResponsiveKey, styleProperty);
      let styleValue;

      if (stylePropertyResult && stylePropertyResult.length > 0) {
        styleValue = style[styleProperty];

        if (typeof styleValue === "object" && !Array.isArray(styleValue)) {
          const {
            flag,
            error
          } = isStyleActive(styleProperty);

          if (flag) {
            responsiveStyle = { ...responsiveStyle,
              ...styleValue
            };
          } else if (error !== null && error !== void 0 && error.msg) {
            throw new Error((error === null || error === void 0 ? void 0 : error.msg) || "Unknown error");
          }

          insertedStyle = false;
        }
      }

      if (insertedStyle) {
        styleValue = style[styleProperty];
        formattedStyle[styleProperty] = styleValue;
      }
    }

    finalStyles[key] = formatStyles({ ...formattedStyle,
      ...responsiveStyle
    });
  }

  return finalStyles;
}

function create(styles) {
  const responsiveStyles = () => {
    const finalStyles = calculateStyles(styles);

    const stylesheet = _reactNative.StyleSheet.create(finalStyles);

    return stylesheet;
  };

  return {
    responsiveStyles,
    styles: responsiveStyles()
  };
}

const CssStyleSheet = { ..._reactNative.StyleSheet,
  create
};
var _default = CssStyleSheet;
exports.default = _default;
//# sourceMappingURL=index.js.map